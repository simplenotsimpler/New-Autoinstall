<#
.SYNOPSIS
Creates a cloud-init config files from a user JSON file for an Ubuntu automated installation.

.DESCRIPTION
Creates a cloud-init config files from a user JSON file for an Ubuntu automated installation. The resulting autoinstall config file is an opinionated configuration for a Django/Nginx server set up on a local VirtualBox machine with a host-only adapter and static IP. The resulting autoinstall config file requires an empty meta-data file which is created during this process.

Feel free to fork and modify the autoinstall heredoc to suit your needs. See NOTES below for further considerations.

.PARAMETER DeployVariablesFile
JSON file which houses variables for deployment. See .https://github.com/simplenotsimpler/New-Autoinstall/sample-deploy-variables.json for JSON schema info.

.PARAMETER OutPath
Path where you want the generated files stored.

If not specified, creates a http folder in folder where script called from.

Note: Packer default is to use a http folder.

.PARAMETER StartLog
Switch. Use this if you want an independent log when this script runs.

.PARAMETER LogFile
Path to log file. If not specified, defaults to "logs\$ModuleName-$LogDate.log".

.EXAMPLE
New-Autoinstall -File "deploy-variables.json" -OutPath "http"

.EXAMPLE
New-Autoinstall -File "deploy-variables.json" -StartLog

.EXAMPLE
New-Autoinstall -File "deploy-variables.json" -StartLog -LogFile "mylog.log"

.INPUTS
None. You cannot pipe objects to New-Autoinstall.

.OUTPUTS
user-data autoinstall config file
meta-data (empty) file

.NOTES
If editing the autoinstall heredoc, be aware of spaces to remain YAML compliant.

After changing the autoinstall heredoc, always validate the generated
autoinstall file using a YAML linter.

If using VS Code, you'll want to disable your spaces auto-detection and set
PowerShell to use 2 spaces instead of 4 spaces.

Markdown help page generated by platyPS.

.LINK
https://ubuntu.com/server/docs/install/autoinstall

.LINK
https://github.com/simplenotsimpler/New-Autoinstall

.LINK
https://github.com/simplenotsimpler/New-PackerVbFile

.LINK
https://github.com/simplenotsimpler/Invoke-PackerBuildVbVm

.LINK
https://github.com/simplenotsimpler/Deploy-VbVm

#>

function New-Autoinstall {
  [CmdletBinding()]
  param (

    [Alias("File")]
    [Parameter(Mandatory = $true)]
    [System.IO.FileInfo]$DeployVariablesFile,
    #validation done in begin block
    [String]$OutPath,
    [Switch]$StartLog,
    [String]$LogFile

  )

  begin{

    $ErrorActionPreference = 'Stop'
    $VerbosePreference = "Continue"
    $ModuleName=$MyInvocation.MyCommand
    $PSDefaultParameterValues = @{"*:Verbose"=$True}
    $LogDate=(Get-Date -Format 'yyyy-MM-dd-HHmm')
    if(!$LogFile){
      $LogFile="logs\$ModuleName-$LogDate.log"
    }
    $Separator="================================"

    if($StartLog){
      Start-Transcript $LogFile -Append
    }

    Write-Verbose $Separator
    Write-Verbose "     Begin $ModuleName Log"
    Write-Verbose $Separator

    #Validate $DeployVariablesFile
    try{
      if( -Not ($DeployVariablesFile | Test-Path -PathType Leaf) ){
          throw "$DeployVariablesFile does not exist"
      }
      if (-Not ((Get-Content -Path $DeployVariablesFile -Raw) | Test-Json -ErrorAction Ignore )){
        throw "$DeployVariablesFile is not valid JSON"
      }
    }
    catch{
      Write-Error "$ModuleName::$_"
    }



    #Create directory if not exist, good error checking
    #https://www.powershelladmin.com/wiki/Powershell_check_if_folder_exists
    Write-Verbose "$ModuleName::Creating Outpath if it doesn't exist"
    if($OutPath){
      if (-Not (Test-Path -LiteralPath $OutPath)) {

        try {
          New-Item -Path $OutPath -ItemType Directory -ErrorAction Stop | Out-Null #-Force
        }
        catch {
          Write-Error -Message "$ModuleName::Unable to create directory '$OutPath'. Error was: $_" -ErrorAction Stop
        }
      }
    } else {
        $OutPath=(New-Item -ItemType Directory -Force -Path "$PWD\http\")
    }
  }

    process{


  #region Convert File to Hashtable
    Write-Verbose "$ModuleName::Processing $DeployVariablesFile"
    $DeployVariablesContent = (Get-Content -Path $DeployVariablesFile -Raw -Encoding UTF8 )

    [Hashtable]$DeployVariables = ($DeployVariablesContent | ConvertFrom-JSON -AsHashTable)

  #endregion Convert File to Hashtable

  #region Generate user-data
  Write-Verbose "$ModuleName::Generating user-data autoinstall file"

  # SOLUTION: need to interpolate using a subexpression with parantheses:
  # https://stackoverflow.com/questions/9540329/formatting-a-powershell-string-containing-hashtable-values
  # Write-Host "Face/$($hash['face'])"

  $Timestamp = $(get-date -f yyyy-MM-dd_HH_mm_ss)

  #due to YAML strictness with spacing, heredoc needs to be all way on left margin
  $UserData = @"
#cloud-config
#generated: $Timestamp
autoinstall:
  version: 1
  network:
    network:
      version: 2
      ethernets:
          enp0s3:
              dhcp4: true
          enp0s8:
              dhcp4: false
              addresses: [$($DeployVariables.UserData.IP)/24]
              nameservers:
                  addresses: [8.8.8.8,8.8.4.4]
  ssh:
    allow-pw: true
    install-server: true
  user-data:
    output:
      all: '| tee -a /var/log/cloud-init-output.log'
    manage_etc_hosts: localhost
    hostname: $($DeployVariables.UserData.Hostname)
    users:
      - name: $($DeployVariables.UserData.Username)
        #sha-512 via mkpasswd
        passwd: "$($DeployVariables.UserData.Passwd)"
        shell: /bin/bash
        lock-passwd: false
        ssh_pwauth: True
        chpasswd: { expire: False }
        primary_group: $($DeployVariables.UserData.Username)
        groups: [adm, cdrom, sudo, dip, plugdev, lxd]
        sudo: ['ALL=(ALL) ALL']
        ssh_authorized_keys:
          - $($DeployVariables.UserData.SSHKey)
    packages:
      - python3-pip
      - python3-dev
      - python3-venv
      - libpq-dev
      - postgresql
      - postgresql-contrib
      - nginx
    package_update: true
    package_upgrade: true
    package_reboot_if_required: true

    #unable to use write_files due to bug:
    # https://bugs.launchpad.net/cloud-init/+bug/1745978
    #unable to use cat + heredoc
    #similar to bug https://gitlab.cncf.ci/kubernetes/kubernetes/commit/6223ca3876abc896619a24123bfbf0a235603463
    runcmd:
      - sudo ufw allow OpenSSH
      - sudo ufw allow 'Nginx Full'
      - sudo ufw enable
      - echo "alias djmake='python manage.py makemigrations'" >> /home/$($DeployVariables.UserData.Username)/.bashrc
      - echo "alias djmigrate='python manage.py migrate'" >> /home/$($DeployVariables.UserData.Username)/.bashrc
      - echo "alias djrunserver='python manage.py runserver 0:8000'" >> /home/$($DeployVariables.UserData.Username)/.bashrc
      - echo "alias mkvenv='python -m venv venv'" >> /home/$($DeployVariables.UserData.Username)/.bashrc
      - echo "alias actvenv='source venv/bin/activate'" >> /home/$($DeployVariables.UserData.Username)/.bashrc
      - echo "alias python='python3'" >> /home/$($DeployVariables.UserData.Username)/.bashrc
      - echo "alias pip='pip3'" >> /home/$($DeployVariables.UserData.Username)/.bashrc
      - source /home/$($DeployVariables.UserData.Username)/.bashrc
      #create file
      - echo "set tabsize 4" > /home/$($DeployVariables.UserData.Username)/.nanorc
      - echo "set tabstospaces" >> /home/$($DeployVariables.UserData.Username)/.nanorc
      - echo "set constantshow" >> /home/$($DeployVariables.UserData.Username)/.nanorc
      - chown ${Username}:${Username} /home/$($DeployVariables.UserData.Username)/.nanorc
      - source /home/$($DeployVariables.UserData.Username)/.nanorc


    final_message: "Cloud init is done.  Woohoo!"
    power_state:
      timeout: 10
      mode: poweroff
      message: Shutting down now.
"@

    $UserData | Out-File $OutPath\user-data

  #endregion Generate user-data

  #region Generate meta-data
    Write-Verbose "$ModuleName::Generating empty meta-data file"
    #create empty meta-data file (needs to be empty for packer and autoinstall)
    New-Item -ItemType File $OutPath\meta-data -Force | Out-Null
  #endregion Generate meta-data
  }
  end {
    Write-Verbose $Separator
    Write-Verbose "      End $ModuleName"
    Write-Verbose $Separator

    if($StartLog){
      Stop-Transcript
    }
  }
}
